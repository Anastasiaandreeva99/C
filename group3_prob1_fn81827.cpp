#include <string>

/***********************************************************************
  Задача 1. Даден е символен низ, състоящ се от кръглите скоби '(',
  ')', запетайки ',' и малки латински букви. Да се реализира функция
  bool valid(const std::string &s, unsigned& error), която проверява
  дали низът, записан в s, е правилно записан функционален израз
  съгласно следните правила:

    <променлива> ::= a | b | … | z
    <израз> ::= <променлива> | <променлива>(<израз>{,<израз>})

  Ако низът s не е коректен, в параметъра error да се запише индексът
  на първия некоректен символ. В реализацията на valid не е позволено
  използването на рекурсия.

  Пример: Например, "f(g(x,y),h(k(u)),v)" е правилно записан израз, но
  "f(g(,x)" и "(f(x),g(y))" не са, като стойността на error е
  съответно 4 и 0.

  Упътване:
    * В стек записваме отварящи скоби, букви и специален символ
    (например '?'), означаващ “резултат от извикването на
    функция”.
    * Какво трябва да има на върха на стека при прочитане на ','?
    * Какво трябва да се случи със стека при прочитане на ','?
    * Какво трябва да има на върха на стека при прочитане на ')'?
    * Какво трябва да се случи със стека при прочитане на ')'?
    * Освен случаите на ',' и ')', какви още проверки за коректност са
    нужни?
    * Какво съдържание трябва да има стекът след приключване на
    програмата?
************************************************************************/

/***********************************************************************
 РЕШЕНИЕ:
************************************************************************/
const char null='@';
bool isChar (char& c)
{
   return (c>='a' && c<='z');
}
bool valid( string& s, unsigned& error)
{
    for(auto el:s)
    {
        if(el!='(' || el!=')'|| !(el>='a' && el<='z'))
            return 0;
    }
    stack<char> st;
    string::iterator it= s.begin();
    if(isChar(*it))st.push(*it);
    it++;
    int countIndex =0;
    for(it;it!=s.end();it++)
    {
        countIndex++;
        if(st.empty() && it==s.end())
        {
            return true;
        }
        if(isChar(*it))
        {
            if(isChar(st.top()))return countIndex;
            else
            st.push(*it);
        }
       if(*it=='(')
       {

           if(isChar(st.top()))
           {   st.pop();//get out the char ,because we are sure it is correct
               st.push('(');//add (

           }
            else countIndex;
       }
       if(*it==',')
       {
           if(st.top()=='(')return countIndex;
           if(isChar(st.top()) || st.top()==null)
           {
               st.pop();
               st.push(*it);
           }
       }
       if(*it==')')
       {
           if(isChar(st.top()))
           {
               while(st.top()!='(')
               {
                   st.pop();
               }
               st.pop();
               st.push(null);
           }
            else return countIndex;
       }
    }
}
/***********************************************************************
 КРАЙ НА РЕШЕНИЕТО
************************************************************************/

#define DOCTEST_CONFIG_IMPLEMENT
#include "doctest.h"

/***********************************************************************
  РАЗКОМЕНТИРАЙТЕ СЛЕДВАЩИЯ РЕД, ЗА ДА ВКЛЮЧИТЕ ТЕСТОВЕТЕ
************************************************************************/
//#include "prob1_tests.h"

int main ()
{
    // пускане на тестовете
    doctest::Context().run();
    return 0;
}
